<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Spatial Navigation Task</title>
  <!-- Your mapping file must define:
       window.stimulusMapping = {
         easy:    [{id,file,egocentric_correct,allocentric_correct}, ...],
         hard:    [...],
         control: [...]
       } -->
  <script src="stimulus_mappings.js"></script>
  <style>
    body {
      margin: 0; padding: 0;
      font-family: Arial, sans-serif;
      background: #fff; color: #222;
      height: 100vh; display: flex; align-items: center; justify-content: center;
      overflow: hidden;
    }
    #experiment-container {
      position: relative;
      width: 100%; max-width: 860px; height: 100vh;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    .screen { display: none; text-align: center; padding: 20px; }
    .screen.active { display: block; }

    .stimulus-stage {
      width: 500px; height: 500px; margin: 0 auto; position: relative;
      display: flex; align-items: center; justify-content: center;
    }
    #stimulus-image {
      position: absolute; inset: 0; width: 100%; height: 100%;
      object-fit: contain; border: 2px solid #ddd; display: none;
    }
    .fixation {
      position: absolute; width: 64px; height: 64px; display: none;
    }
    .fixation::before, .fixation::after {
      content: ""; position: absolute; background: #333; border-radius: 1px;
    }
    .fixation::before { /* vertical */ left: 50%; transform: translateX(-50%); top: 0; width: 2px; height: 100%; }
    .fixation::after  { /* horizontal */ top: 50%; transform: translateY(-50%); left: 0; width: 100%; height: 2px; }

    .instruction-text { font-size: 18px; line-height: 1.5; max-width: 640px; margin: 0 auto; }
    .button {
      background: #4CAF50; color: #fff; border: 0; border-radius: 6px;
      padding: 12px 22px; font-size: 16px; cursor: pointer; margin-top: 14px;
    }
    .button:hover { background: #45a049; }
    .button:disabled { background: #bbb; cursor: not-allowed; }
    .progress { position: absolute; top: 10px; right: 10px; font-size: 14px; color: #666; }

    .nav-type-header {
      display: inline-block; padding: 8px 16px; border-radius: 6px; color: #fff; font-weight: bold; margin: 10px 0 16px;
    }
    .egocentric-header { background: #4CAF50; }
    .allocentric-header { background: #9C27B0; }
    .control-header { background: #FF9800; }

    .form-group { margin: 10px 0; }
    .form-group label { display: inline-block; width: 160px; text-align: right; margin-right: 10px; }
    input[type="number"], select {
      padding: 8px; font-size: 16px; width: 220px; border: 1px solid #ddd; border-radius: 4px;
    }

    .hint { font-size: 12px; color: #666; font-style: italic; margin-top: 6px; }
    .debug { position: fixed; left: 8px; bottom: 8px; background: rgba(255,255,255,.9); border: 1px solid #eee; padding: 6px 8px; font-size: 11px; max-width: 320px; display: none; }
    .debug.active { display: block; }
  </style>
</head>
<body>
  <div id="experiment-container">
    <div class="progress" id="progress"></div>

    <!-- Data Entry -->
    <div id="data-entry-screen" class="screen active">
      <h2>Spatial Navigation Task</h2>

      <div class="form-group">
        <label>Participant Group:</label>
        <select id="participant-group" onchange="onGroupChange()">
          <option value="">Select your group...</option>
          <option value="DF">Deaf Fluent Signer</option>
          <option value="HF">Hearing Fluent Signer</option>
          <option value="DNF">Deaf Non-Fluent Signer</option>
          <option value="HNF">Hearing Non-Fluent Signer</option>
          <option value="HNS">Hearing Non-Signer</option>
        </select>
      </div>
      <div id="group-desc" class="hint"></div>

      <div class="form-group">
        <label>Age:</label>
        <input type="number" id="age" min="18" max="100">
      </div>
      <div class="form-group">
        <label>Gender:</label>
        <select id="gender">
          <option value="">Select...</option>
          <option value="male">Male</option>
          <option value="female">Female</option>
          <option value="non-binary">Non-binary</option>
          <option value="prefer-not">Prefer not to say</option>
        </select>
      </div>
      <div class="form-group">
        <label>Handedness:</label>
        <select id="handedness">
          <option value="">Select...</option>
          <option value="right">Right</option>
          <option value="left">Left</option>
          <option value="ambidextrous">Ambidextrous</option>
        </select>
      </div>

      <button class="button" id="start-button" onclick="startExperiment()" disabled>
        Please select your group first
      </button>
    </div>

    <!-- Instructions -->
    <div id="instruction-screen" class="screen">
      <div id="nav-type-indicator"></div>
      <div id="instruction-text" class="instruction-text"></div>
      <button class="button" id="instruction-continue">Continue</button>
    </div>

    <!-- Stimulus -->
    <div id="stimulus-screen" class="screen">
      <div class="stimulus-stage">
        <img id="stimulus-image" src="" alt="Stimulus">
        <div class="fixation" id="fixation" aria-hidden="true"></div>
      </div>
    </div>

    <!-- Feedback / Completion -->
    <div id="feedback-screen" class="screen">
      <div id="feedback-text" style="font-size:24px; margin: 20px;"></div>
      <button class="button" id="download-data" onclick="downloadData()" style="display:none;">Download Data</button>
    </div>

    <div id="debug" class="debug"></div>
  </div>

  <script>
    /********* CONFIG *********/
    const GOOGLE_SHEET_URL = 'https://script.google.com/macros/s/AKfycbzw_gLBsA5hY1dU7xZ1Fp67FptHEC9veo95vyId0bBOfu_QLMNFm02Rg0iRzURzx2Cn/exec';

    const urlParams = new URLSearchParams(window.location.search);
    const debugMode = urlParams.get('debug') === 'true';
    if (debugMode) document.getElementById('debug').classList.add('active');

    const GROUP_DESCRIPTIONS = {
      DF: 'Deaf individuals who are fluent in sign language',
      HF: 'Hearing individuals who are fluent in sign language',
      DNF: 'Deaf individuals who are not fluent in sign language',
      HNF: 'Hearing individuals who are not fluent in sign language',
      HNS: 'Hearing individuals who do not know sign language'
    };

    // 2 nav types × 2 difficulties × 2 reps + 1 control block inserted mid-run → 9 total blocks.
    const config = {
      trialsPerBlock: 15,
      maxResponseTime: 3000,   // ms
      fixationDuration: 800,   // ms
      itiDuration: 400,        // ms (main task only)
      practiceTrials: 4,       // 2 ego + 2 allo
      repetitions: 2,          // each (ego/allo)×(easy/hard) twice
      blocks: []
    };

    const state = {
      participantInfo: {},
      isPractice: false,
      currentBlock: 0,
      currentTrial: 0,
      currentBlockStimuli: [],
      usedStimuliTracker: {},   // key "nav_diff" -> Set(ids)
      currentStimulus: null,
      currentNavType: null,
      currentDifficulty: null,
      stimulusOnsetTime: null,
      responseTimeout: null,
      onKeyHandler: null,
      allData: [],
      blockData: []
    };

    // Participant-friendly instructions
    const INSTRUCTIONS = {
      brief: {
        egocentric: `
PLAYER VIEW:
UP = forward (direction you're facing)
DOWN = backward
LEFT = to your left
RIGHT = to your right
        `,
        allocentric: `
MAP VIEW:
UP = toward the top of the screen
DOWN = toward the bottom of the screen
LEFT = toward the left side of the screen
RIGHT = toward the right of the screen
        `,
        control: `
ARROW FOLLOWING:
Press the arrow matching the FIRST arrow from the player.
UP / DOWN / LEFT / RIGHT
        `
      }
    };

    function prettyHeader(navType) {
      return navType === 'egocentric' ? 'PLAYER VIEW'
           : navType === 'allocentric' ? 'MAP VIEW'
           : 'ARROW FOLLOWING';
    }

    /********* UTILS *********/
    function showScreen(id) {
      ['data-entry-screen','instruction-screen','stimulus-screen','feedback-screen'].forEach(s => {
        const el = document.getElementById(s);
        if (el) el.classList.toggle('active', s === id);
      });
    }
    function setInstructionContinue(handler) {
      const btn = document.getElementById('instruction-continue');
      btn.onclick = handler;
      btn.style.display = 'inline-block';
    }
    function hideInstructionContinue() {
      document.getElementById('instruction-continue').style.display = 'none';
    }
    function debugLog(msg) {
      if (!debugMode) return;
      const d = document.getElementById('debug');
      d.innerHTML = (new Date().toLocaleTimeString()) + ' — ' + msg + '<br>' + d.innerHTML;
    }
    function updateProgress() {
      const el = document.getElementById('progress');
      if (state.isPractice) {
        el.textContent = `Practice | Trial ${state.currentTrial + 1}/${config.practiceTrials}`;
      } else {
        const totalBlocks = config.blocks.length || 1;
        el.textContent = `Block ${state.currentBlock + 1}/${totalBlocks} | Trial ${state.currentTrial + 1}/${config.trialsPerBlock}`;
      }
    }
    function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

    class RNG {
      constructor(seed){ this.seed = seed; }
      random(){
        let t = this.seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
      shuffle(arr){
        const a = [...arr];
        for (let i=a.length-1; i>0; i--){
          const j = Math.floor(this.random()*(i+1));
          [a[i],a[j]]=[a[j],a[i]];
        }
        return a;
      }
    }
    function rngFromId(id){
      const base = String(id).split('').reduce((acc,c)=>acc+c.charCodeAt(0),0);
      const jitter = Date.now()%1000;
      return new RNG(base*1000 + jitter);
    }

    // Counterbalance from participant id → 1..4
    function determineCounterbalance(participantId){
      const m = String(participantId).match(/\d+/);
      const n = m ? parseInt(m[0],10) : [...String(participantId)].reduce((a,c)=>a+c.charCodeAt(0),0);
      return (n % 4) + 1;
    }

    // Latin-square over [(ego, easy), (ego, hard), (allo, easy), (allo, hard)] ×2; insert one control in the middle.
    function createBlockSequence(counterbalance){
      const latin = [
        [['egocentric','easy'], ['egocentric','hard'], ['allocentric','easy'], ['allocentric','hard']],
        [['egocentric','hard'], ['allocentric','hard'], ['egocentric','easy'], ['allocentric','easy']],
        [['allocentric','easy'], ['egocentric','easy'], ['allocentric','hard'], ['egocentric','hard']],
        [['allocentric','hard'], ['allocentric','easy'], ['egocentric','hard'], ['egocentric','easy']]
      ];
      const base = latin[counterbalance-1];
      const seq = [];
      for (let r=0; r<config.repetitions; r++){
        base.forEach(([n,d]) => seq.push({navType:n, difficulty:d}));
      }
      seq.splice(4, 0, {navType:'control', difficulty:'control'}); // insert control once
      debugLog('Block sequence: ' + seq.map(b=>b.navType+'/'+b.difficulty).join(' | '));
      return seq;
    }

    function ensureEnough(stimuli, need, rng){
      if (stimuli.length === 0) return [];
      let pool = [...stimuli];
      if (pool.length < need) {
        const reps = Math.ceil(need / pool.length);
        pool = Array.from({length: reps}, ()=>rng.shuffle(stimuli)).flat();
      }
      pool = rng.shuffle(pool);
      return pool.slice(0, need);
    }

    function prepareBlockStimuli(navType, difficulty, blockIndex, rng, count){
      const bucket = stimulusMapping && stimulusMapping[difficulty];
      if (!bucket || !bucket.length) {
        alert(`No stimuli for difficulty: ${difficulty}`);
        return [];
      }
      const key = navType + '_' + difficulty;
      if (!state.usedStimuliTracker[key]) state.usedStimuliTracker[key] = new Set();

      const unused = bucket.filter(s => !state.usedStimuliTracker[key].has(s.id));
      const used   = bucket.filter(s =>  state.usedStimuliTracker[key].has(s.id));
      let pool = [...unused, ...used];
      for (let i=0;i<2;i++) pool = rng.shuffle(pool);

      const chosen = ensureEnough(pool, count, rng);
      chosen.forEach(s => state.usedStimuliTracker[key].add(s.id));

      debugLog(`Prepared block ${blockIndex+1} ${navType}/${difficulty} -> ${chosen.length}`);
      return chosen;
    }

    async function preloadImages(stimuli) {
      await Promise.all(stimuli.map(s => new Promise(res => {
        const img = new Image(); img.onload = res; img.onerror = res; img.src = s.file;
      })));
    }

    // Apps Script ID (with offline fallback)
    async function getUniqueIdFromServer(groupCode) {
      const res = await fetch(GOOGLE_SHEET_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'text/plain;charset=utf-8' },
        body: JSON.stringify({ action: 'nextIdLocked', groupCode })
      });
      if (!res.ok) throw new Error('ID server responded ' + res.status);
      const data = await res.json();
      if (!data.ok || !data.id) throw new Error(data.error || 'Bad response');
      return data.id;
    }
    function fallbackLocalId(groupCode) {
      const bytes = new Uint8Array(8); crypto.getRandomValues(bytes);
      const hex = Array.from(bytes).map(b=>b.toString(16).padStart(2,'0')).join('').slice(0,8);
      return `${groupCode}-tmp-${Date.now().toString(36)}-${hex}`;
    }
    async function saveToGoogleSheet(payload){
      try {
        const body = { action: 'saveTrial', ...payload, user_agent: navigator.userAgent };
        await fetch(GOOGLE_SHEET_URL, { method:'POST', mode:'no-cors',
          headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
      } catch(e){ debugLog('saveToGoogleSheet failed (local-only)'); }
    }

    /********* UI HOOKS *********/
    function onGroupChange(){
      const group = document.getElementById('participant-group').value;
      const startBtn = document.getElementById('start-button');
      const desc = document.getElementById('group-desc');
      if (group) { desc.textContent = GROUP_DESCRIPTIONS[group] || ''; startBtn.disabled = false; startBtn.textContent='Start Experiment'; }
      else { desc.textContent=''; startBtn.disabled = true; startBtn.textContent='Please select your group first'; }
    }

    async function startExperiment(){
      const group = document.getElementById('participant-group').value;
      const age = document.getElementById('age').value;
      const gender = document.getElementById('gender').value;
      const handedness = document.getElementById('handedness').value;
      if (!group) return alert('Please select your participant group first');
      if (!age || !gender || !handedness) return alert('Please fill in all required fields (Age, Gender, Handedness)');

      const startBtn = document.getElementById('start-button');
      startBtn.disabled = true; startBtn.textContent = 'Assigning ID...';

      let assignedId;
      try { assignedId = await getUniqueIdFromServer(group); }
      catch(e){ debugLog('ID server failed: ' + e.message); assignedId = fallbackLocalId(group); }

      state.participantInfo = { id: assignedId, group, age, gender, handedness, timestamp: new Date().toISOString() };

      // Build block plan
      const cb = determineCounterbalance(assignedId);
      config.blocks = createBlockSequence(cb);
      state.usedStimuliTracker = {};

      // Clear practice counters
      state.isPractice = true;
      state.currentTrial = 0;

      // Practice overview — explicitly mentions the two question types
      const txt = document.getElementById('instruction-text');
      const head = document.getElementById('nav-type-indicator'); head.className=''; head.textContent='';
      txt.innerHTML = `
        <h3>Practice Phase (2 short parts)</h3>
        <p>You will answer <strong>two kinds of practice questions</strong>:</p>
        <p><strong>1) PLAYER VIEW</strong> — act as if you are the player:<br>
        UP = forward, DOWN = backward, LEFT/RIGHT = turn</p>
        <p><strong>2) MAP VIEW</strong> — use screen directions like a map:<br>
        UP = top of the screen, DOWN = bottom, LEFT = left, RIGHT = right</p>
        <p>You will do <strong>2 questions of each type</strong>. Between them, you’ll see a brief reminder of the next type.<br>
        You’ll get quick “Correct/Incorrect” feedback in practice.</p>
        <p>Press <strong>Continue</strong> to begin practice.</p>`;
      setInstructionContinue(()=> { runPracticeTrial(/*showBannerIfNeeded=*/true); });
      showScreen('instruction-screen');

      // re-enable start for safety if user returns
      startBtn.disabled = false; startBtn.textContent = 'Start Experiment';
    }

    /********* PRACTICE FLOW *********/
    // Show a brief auto-advancing banner when switching practice types (no extra button)
    async function showPracticeTypeBanner(navType, thenStartFn){
      const head = document.getElementById('nav-type-indicator');
      const txt = document.getElementById('instruction-text');
      head.className = `nav-type-header ${navType}-header`;
      head.textContent = prettyHeader(navType);

      txt.innerHTML = `
        <pre style="text-align:left; white-space:pre-wrap; line-height:1.4; font-family:inherit;">
${INSTRUCTIONS.brief[navType].trim()}
        </pre>
        <p>Next: <strong>${prettyHeader(navType)}</strong> practice — 2 quick questions. Starting...</p>`;
      hideInstructionContinue();
      showScreen('instruction-screen');
      await sleep(900); // brief pause to orient
      thenStartFn();
    }

    function runPracticeTrial(showBannerIfNeeded=false){
      if (!state.isPractice) return; // safety

      if (state.currentTrial >= config.practiceTrials) {
        // Practice → break screen before main task
        state.isPractice = false;
        state.currentBlock = 0; state.currentTrial = 0;

        const txt = document.getElementById('instruction-text');
        const head = document.getElementById('nav-type-indicator'); head.className=''; head.textContent='';
        txt.innerHTML = `
          <h3>Practice Complete</h3>
          <p>The main task will begin next.</p>
          <p>You can take a short break now. Press <strong>Continue</strong> when ready.</p>`;
        setInstructionContinue(showBlockInstructions);
        showScreen('instruction-screen');
        return;
      }

      // Determine current practice type (first 2 = ego, next 2 = allo)
      const navType = state.currentTrial < 2 ? 'egocentric' : 'allocentric';
      const stim = stimulusMapping.easy[state.currentTrial % stimulusMapping.easy.length];

      // If we just switched types (trial 2), show a brief banner without adding a button
      if (showBannerIfNeeded || state.currentTrial === 2) {
        const needBanner = (state.currentTrial === 0) || (state.currentTrial === 2);
        if (needBanner) {
          showPracticeTypeBanner(navType, () => presentStimulus(stim, navType, 'practice'));
          return;
        }
      }

      presentStimulus(stim, navType, 'practice');
      updateProgress();
    }

    /********* MAIN BLOCKS *********/
    function showBlockInstructions(){
      const block = config.blocks[state.currentBlock];
      const head = document.getElementById('nav-type-indicator');
      const txt = document.getElementById('instruction-text');

      const name = prettyHeader(block.navType);
      head.className = `nav-type-header ${block.navType}-header`;
      head.textContent = name;

      const msg = {
        egocentric: `Navigate from the gray player to the red stop sign.<br><br>
                     Use arrow keys as if YOU are the player:<br>
                     UP = forward, DOWN = backward, LEFT = turn left, RIGHT = turn right`,
        allocentric:`Navigate from the gray player to the red stop sign.<br><br>
                     Use arrow keys as map directions:<br>
                     UP = north (top), DOWN = south (bottom), LEFT = west, RIGHT = east`,
        control:    `Follow the arrows shown.<br><br>
                     Press the arrow key matching the FIRST arrow from the player.`
      };
      txt.innerHTML = msg[block.navType];

      setInstructionContinue(startBlock);
      updateProgress();
      showScreen('instruction-screen');
    }

    async function startBlock(){
      const block = config.blocks[state.currentBlock];
      const rng = rngFromId(state.participantInfo.id + '_b' + state.currentBlock);
      state.currentBlockStimuli = prepareBlockStimuli(block.navType, block.difficulty, state.currentBlock, rng, config.trialsPerBlock);
      state.currentTrial = 0; state.blockData = [];
      await preloadImages(state.currentBlockStimuli);
      nextTrial();
    }

    function nextTrial(){
      if (state.isPractice) return; // safety

      if (state.currentTrial >= config.trialsPerBlock) {
        // end of block
        state.allData.push(...state.blockData);
        state.blockData = [];
        state.currentBlock++;
        if (state.currentBlock >= config.blocks.length) {
          showCompletion();
        } else {
          showBlockInstructions(); // break between blocks
        }
        return;
      }

      const block = config.blocks[state.currentBlock];
      const stim = state.currentBlockStimuli[state.currentTrial];
      if (!stim) {
        debugLog('Missing stimulus at idx ' + state.currentTrial + ' — skipping');
        state.currentTrial++;
        return nextTrial();
      }

      presentStimulus(stim, block.navType, block.difficulty);
      updateProgress();
      // increment happens after logging the response
    }

    /********* PRESENT & RESPOND *********/
    function presentStimulus(stimulus, navType, difficulty){
      state.currentStimulus = stimulus;
      state.currentNavType = navType;
      state.currentDifficulty = difficulty;

      const img = document.getElementById('stimulus-image');
      const fix = document.getElementById('fixation');

      img.style.display = 'none';
      fix.style.display = 'block';
      showScreen('stimulus-screen');

      setTimeout(()=> {
        fix.style.display = 'none';
        img.src = stimulus.file;
        img.style.display = 'block';
        state.stimulusOnsetTime = performance.now();

        // One-time key handler + timeout
        state.onKeyHandler = (e)=> handleResponse(e);
        document.addEventListener('keydown', state.onKeyHandler, { once: true });
        state.responseTimeout = setTimeout(()=> {
          if (state.onKeyHandler) {
            document.removeEventListener('keydown', state.onKeyHandler);
            state.onKeyHandler = null;
          }
          handleResponse({ key: 'timeout' });
        }, config.maxResponseTime);

      }, config.fixationDuration);
    }

    function handleResponse(event){
      const valid = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','timeout'];
      const key = event.key || event;
      if (!valid.includes(key)) {
        // rearm single listener if a wrong key was pressed
        document.addEventListener('keydown', state.onKeyHandler = (e)=>handleResponse(e), { once: true });
        return;
      }

      clearTimeout(state.responseTimeout);
      if (state.onKeyHandler) {
        document.removeEventListener('keydown', state.onKeyHandler);
        state.onKeyHandler = null;
      }

      const map = { ArrowUp:'up', ArrowDown:'down', ArrowLeft:'left', ArrowRight:'right', timeout:'none' };
      const response = map[key];
      const rt = key === 'timeout' ? null : Math.round(performance.now() - state.stimulusOnsetTime);

      // Score
      let correct;
      if (state.currentNavType === 'egocentric')
        correct = state.currentStimulus.egocentric_correct;
      else if (state.currentNavType === 'allocentric')
        correct = state.currentStimulus.allocentric_correct;
      else // control block: use whichever mapping is present (prefer ego)
        correct = state.currentStimulus.egocentric_correct ?? state.currentStimulus.allocentric_correct;

      const accuracy = response === correct ? 1 : 0;

      const common = {
        participant_id: state.participantInfo.id,
        participant_group: state.participantInfo.group,
        age: state.participantInfo.age,
        gender: state.participantInfo.gender,
        handedness: state.participantInfo.handedness,
        navigation_type: state.currentNavType,
        difficulty: state.currentDifficulty,
        stimulus_id: state.currentStimulus.id,
        response, correct_response: correct, accuracy, rt_ms: rt,
        timestamp: new Date().toISOString()
      };

      if (state.isPractice) {
        // Practice feedback (brief), then next practice trial
        saveToGoogleSheet({ ...common, block: 'practice', trial: state.currentTrial + 1 });
        showPracticeFeedback(accuracy);
      } else {
        // Main task: add to block data
        const trialNum = state.currentTrial + 1;
        state.blockData.push({ ...common, block: state.currentBlock + 1, trial: trialNum });
        state.allData.push({ ...common, block: state.currentBlock + 1, trial: trialNum }); // also store to allData live
        saveToGoogleSheet({ ...common, block: state.currentBlock + 1, trial: trialNum });

        // advance trial counter only AFTER logging
        state.currentTrial += 1;
        setTimeout(()=> nextTrial(), config.itiDuration);
      }
    }

    function showPracticeFeedback(ok){
      const txt = document.getElementById('feedback-text');
      const dl  = document.getElementById('download-data');
      txt.textContent = ok ? 'Correct!' : 'Incorrect';
      txt.style.color = ok ? 'green' : 'red';
      dl.style.display = 'none';
      showScreen('feedback-screen');
      setTimeout(()=> {
        showScreen('stimulus-screen');
        state.currentTrial += 1;
        // For trial 2 (switch to MAP VIEW), show a quick banner before the next trial
        if (state.currentTrial === 2) {
          runPracticeTrial(true);
        } else {
          runPracticeTrial(false);
        }
      }, 900);
    }

    /********* FINISH *********/
    async function showCompletion(){
      const totalCorrect = state.allData.filter(d=>d.accuracy===1).length;
      const acc = state.allData.length ? (totalCorrect / state.allData.length * 100).toFixed(1) : '—';
      const meanRt = (state.allData.reduce((s,d)=> s + (d.rt_ms || 0), 0) /
                     Math.max(1, state.allData.filter(d=>d.rt_ms!=null).length)).toFixed(0);

      // Summary row
      const summary = {
        participant_id: state.participantInfo.id,
        participant_group: state.participantInfo.group,
        age: state.participantInfo.age,
        gender: state.participantInfo.gender,
        handedness: state.participantInfo.handedness,
        total_trials: state.allData.length,
        total_correct: totalCorrect,
        overall_accuracy: acc,
        mean_rt: meanRt,
        completion_time: new Date().toISOString(),
        trial: 'SUMMARY', block: 'SUMMARY', navigation_type: 'SUMMARY', difficulty: 'SUMMARY'
      };
      await saveToGoogleSheet(summary);

      const txt = document.getElementById('feedback-text');
      const dl  = document.getElementById('download-data');
      txt.innerHTML = `
        <h2>Experiment Complete!</h2>
        <p>Thank you for participating.</p>
        <p>Your data has been saved.</p>
        <p>Overall accuracy: ${acc}%</p>
        <p>Participant ID: ${state.participantInfo.id}</p>
        <hr style="margin: 20px 0;">
        <p class="hint">Optional: Download a backup copy of your data below</p>`;
      txt.style.color = '#333';
      dl.style.display = 'inline-block';
      showScreen('feedback-screen');
    }

    function downloadData(){
      if (!state.allData.length) return alert('No data to download');
      const headers = Object.keys(state.allData[0]);
      const csv = [
        headers.join(','),
        ...state.allData.map(r =>
          headers.map(h => {
            const v = r[h];
            if (typeof v === 'string' && v.includes(',')) return `"${v.replace(/"/g,'""')}"`;
            return v ?? '';
          }).join(',')
        )
      ].join('\n');

      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `spatial_nav_${state.participantInfo.id}_${Date.now()}.csv`;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    /********* STARTUP GUARD *********/
    if (!window.stimulusMapping) {
      alert('Error: Stimulus mappings not loaded. Please refresh.');
      console.error('stimulusMapping is not defined');
    }
  </script>
</body>
</html>
