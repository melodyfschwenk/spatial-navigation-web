<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spatial Navigation Task</title>
    <script src="stimulus_mappings.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: white;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        #experiment-container {
            width: 100%;
            max-width: 800px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: white;
        }
        
        #instruction-screen, #stimulus-screen, #feedback-screen, #data-entry-screen {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        #instruction-screen.active, #stimulus-screen.active, 
        #feedback-screen.active, #data-entry-screen.active {
            display: block;
        }
        
        #stimulus-image {
            max-width: 500px;
            max-height: 500px;
            border: 2px solid #ddd;
        }
        
        .instruction-text {
            font-size: 18px;
            line-height: 1.5;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px;
            border-radius: 4px;
        }
        
        .button:hover {
            background: #45a049;
        }
        
        .fixation {
            font-size: 48px;
            font-weight: bold;
            color: #333;
        }
        
        .progress {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 14px;
            color: #666;
        }
        
        .nav-type-header {
            padding: 10px 20px;
            margin: 20px 0;
            font-weight: bold;
            color: white;
            font-size: 20px;
        }
        
        .egocentric-header {
            background: #4CAF50;
        }
        
        .allocentric-header {
            background: #9C27B0;
        }
        
        .control-header {
            background: #FF9800;
        }
        
        input[type="text"], input[type="number"], select {
            padding: 8px;
            margin: 5px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .form-group {
            margin: 15px 0;
        }
        
        .form-group label {
            display: inline-block;
            width: 150px;
            text-align: right;
            margin-right: 10px;
        }
        
        #download-data {
            display: none;
            background: #2196F3;
        }
        
        #download-data:hover {
            background: #1976D2;
        }
    </style>
</head>
<body>
    <div id="experiment-container">
        <div class="progress" id="progress"></div>
        
        <!-- Data Entry Screen -->
        <div id="data-entry-screen" class="active">
            <h2>Spatial Navigation Task</h2>
            <div class="form-group">
                <label>Participant ID:</label>
                <input type="text" id="participant-id" placeholder="Enter ID">
            </div>
            <div class="form-group">
                <label>Age:</label>
                <input type="number" id="age" min="18" max="100">
            </div>
            <div class="form-group">
                <label>Gender:</label>
                <select id="gender">
                    <option value="">Select...</option>
                    <option value="male">Male</option>
                    <option value="female">Female</option>
                    <option value="non-binary">Non-binary</option>
                    <option value="prefer-not">Prefer not to say</option>
                </select>
            </div>
            <div class="form-group">
                <label>Handedness:</label>
                <select id="handedness">
                    <option value="">Select...</option>
                    <option value="right">Right</option>
                    <option value="left">Left</option>
                    <option value="ambidextrous">Ambidextrous</option>
                </select>
            </div>
            <button class="button" onclick="startExperiment()">Start Experiment</button>
        </div>
        
        <!-- Instruction Screen -->
        <div id="instruction-screen">
            <div id="nav-type-indicator"></div>
            <div class="instruction-text" id="instruction-text"></div>
            <button class="button" onclick="startBlock()">Continue</button>
        </div>
        
        <!-- Stimulus Screen -->
        <div id="stimulus-screen">
            <img id="stimulus-image" src="" alt="Stimulus">
            <div class="fixation" id="fixation" style="display:none;">+</div>
        </div>
        
        <!-- Feedback Screen -->
        <div id="feedback-screen">
            <div id="feedback-text" style="font-size: 24px; margin: 20px;"></div>
            <button class="button" id="continue-button" onclick="nextTrial()">Continue</button>
            <button class="button" id="download-data" onclick="downloadData()">Download Data</button>
        </div>
    </div>

    <script>
        // Experiment configuration
        const config = {
            trialsPerBlock: 15,
            maxResponseTime: 3000, // ms
            feedbackDuration: 500, // ms
            fixationDuration: 800, // ms
            practiceTrials: 4,
            blocks: [] // Will be populated based on counterbalancing
        };

        // Experiment state
        let state = {
            participantInfo: {},
            currentBlock: 0,
            currentTrial: 0,
            blockData: [],
            allData: [],
            trialStartTime: null,
            stimulusOnsetTime: null,
            isPractice: false
        };

        

        // Load stimulus mapping from CSV
        async function loadStimulusMapping() {
            // In a real implementation, you would load your CSV file here
            // For now, using placeholder data structure
            // You'll need to implement CSV parsing or convert to JSON
            
            // Example structure:
            for (let i = 1; i <= 26; i++) {
                stimulusMapping.easy.push({
                    id: `easy_${i}`,
                    file: `stimuli/${i}.png`,
                    egocentric_correct: ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)],
                    allocentric_correct: ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)]
                });
            }
            for (let i = 27; i <= 52; i++) {
                stimulusMapping.hard.push({
                    id: `hard_${i}`,
                    file: `stimuli/${i}.png`,
                    egocentric_correct: ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)],
                    allocentric_correct: ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)]
                });
            }
            for (let i = 53; i <= 78; i++) {
                stimulusMapping.control.push({
                    id: `control_${i}`,
                    file: `stimuli/${i}.png`,
                    egocentric_correct: ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)],
                    allocentric_correct: ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)]
                });
            }
        }

        // Generate block sequence based on counterbalancing
        function generateBlockSequence(participantId) {
            // Simple counterbalancing based on participant ID
            const cb = (parseInt(participantId) || 0) % 4 + 1;
            
            const latinSquare = [
                [['egocentric', 'easy'], ['egocentric', 'hard'], ['allocentric', 'easy'], ['allocentric', 'hard']],
                [['egocentric', 'hard'], ['allocentric', 'hard'], ['egocentric', 'easy'], ['allocentric', 'easy']],
                [['allocentric', 'easy'], ['egocentric', 'easy'], ['allocentric', 'hard'], ['egocentric', 'hard']],
                [['allocentric', 'hard'], ['allocentric', 'easy'], ['egocentric', 'hard'], ['egocentric', 'easy']]
            ];
            
            const sequence = latinSquare[cb - 1];
            const blocks = [];
            
            // Add each condition twice (as per original with 2 repetitions)
            sequence.forEach(([navType, difficulty]) => {
                blocks.push({ navType, difficulty });
                blocks.push({ navType, difficulty });
            });
            
            // Add control block
            blocks.splice(4, 0, { navType: 'control', difficulty: 'control' });
            
            return blocks;
        }

        // Start experiment
        function startExperiment() {
            // Collect participant info
            state.participantInfo = {
                id: document.getElementById('participant-id').value || 'test',
                age: document.getElementById('age').value,
                gender: document.getElementById('gender').value,
                handedness: document.getElementById('handedness').value,
                timestamp: new Date().toISOString()
            };
            
            // Generate block sequence
            config.blocks = generateBlockSequence(state.participantInfo.id);
            
            // Load stimuli and start
            loadStimulusMapping().then(() => {
                // Start with practice
                state.isPractice = true;
                showPracticeInstructions();
            });
            
            document.getElementById('data-entry-screen').classList.remove('active');
        }

        // Show practice instructions
        function showPracticeInstructions() {
            const instructionScreen = document.getElementById('instruction-screen');
            const instructionText = document.getElementById('instruction-text');
            
            instructionText.innerHTML = `
                <h3>Practice Phase</h3>
                <p>You will now practice the two navigation types:</p>
                <p><strong>PLAYER VIEW:</strong> Navigate as if you are the player<br>
                UP = forward, DOWN = backward, LEFT/RIGHT = turn</p>
                <p><strong>MAP VIEW:</strong> Navigate using map directions<br>
                UP = north, DOWN = south, LEFT = west, RIGHT = east</p>
                <p>Press Continue to start practice trials.</p>
            `;
            
            instructionScreen.classList.add('active');
        }

        // Show instructions for current block
        function showBlockInstructions() {
            const block = config.blocks[state.currentBlock];
            const instructionScreen = document.getElementById('instruction-screen');
            const instructionText = document.getElementById('instruction-text');
            const navIndicator = document.getElementById('nav-type-indicator');
            
            // Set navigation type header
            navIndicator.className = `nav-type-header ${block.navType}-header`;
            navIndicator.textContent = block.navType === 'egocentric' ? 'PLAYER VIEW' : 
                                      block.navType === 'allocentric' ? 'MAP VIEW' : 'ARROW FOLLOWING';
            
            // Set instruction text
            const instructions = {
                egocentric: `Navigate from the gray player to the red stop sign.<br><br>
                            Use arrow keys as if YOU are the player:<br>
                            UP = Move forward<br>
                            DOWN = Move backward<br>
                            LEFT = Turn left<br>
                            RIGHT = Turn right`,
                allocentric: `Navigate from the gray player to the red stop sign.<br><br>
                             Use arrow keys for map directions:<br>
                             UP = Move north (top of screen)<br>
                             DOWN = Move south (bottom)<br>
                             LEFT = Move west (left side)<br>
                             RIGHT = Move east (right side)`,
                control: `Follow the arrows shown.<br><br>
                         Press the arrow key matching the FIRST arrow from the player.`
            };
            
            instructionText.innerHTML = instructions[block.navType];
            instructionScreen.classList.add('active');
            
            // Update progress
            updateProgress();
        }

        // Start current block
        function startBlock() {
            document.getElementById('instruction-screen').classList.remove('active');
            
            if (state.isPractice) {
                // Start practice trials
                state.currentTrial = 0;
                state.blockData = [];
                runPracticeTrial();
            } else {
                // Start main experiment block
                state.currentTrial = 0;
                state.blockData = [];
                nextTrial();
            }
        }

        // Run practice trial
        function runPracticeTrial() {
            if (state.currentTrial >= config.practiceTrials) {
                // Practice complete
                state.isPractice = false;
                state.currentBlock = 0;
                showBlockInstructions();
                return;
            }
            
            // Alternate between egocentric and allocentric for practice
            const navType = state.currentTrial < 2 ? 'egocentric' : 'allocentric';
            const stimuli = stimulusMapping.easy;
            const stimulus = stimuli[state.currentTrial % stimuli.length];
            
            presentStimulus(stimulus, navType, 'practice');
        }

        // Present stimulus
        function presentStimulus(stimulus, navType, difficulty) {
            const stimulusScreen = document.getElementById('stimulus-screen');
            const stimulusImage = document.getElementById('stimulus-image');
            const fixation = document.getElementById('fixation');
            
            // Show fixation first
            fixation.style.display = 'block';
            stimulusImage.style.display = 'none';
            stimulusScreen.classList.add('active');
            
            setTimeout(() => {
                // Show stimulus
                fixation.style.display = 'none';
                stimulusImage.style.display = 'block';
                stimulusImage.src = stimulus.file;
                
                state.stimulusOnsetTime = Date.now();
                state.trialStartTime = Date.now();
                
                // Set up response handling
                document.addEventListener('keydown', handleResponse);
                
                // Timeout for no response
                state.responseTimeout = setTimeout(() => {
                    handleResponse({ key: 'timeout' });
                }, config.maxResponseTime);
                
            }, config.fixationDuration);
        }

        // Handle keyboard response
        function handleResponse(event) {
            // Only process arrow keys and timeout
            const validKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'timeout'];
            
            let responseKey = event.key || event;
            if (!validKeys.includes(responseKey)) return;
            
            // Clear timeout
            clearTimeout(state.responseTimeout);
            
            // Remove event listener
            document.removeEventListener('keydown', handleResponse);
            
            // Calculate RT
            const rt = responseKey === 'timeout' ? null : Date.now() - state.stimulusOnsetTime;
            
            // Map response
            const responseMap = {
                'ArrowUp': 'up',
                'ArrowDown': 'down',
                'ArrowLeft': 'left',
                'ArrowRight': 'right',
                'timeout': 'none'
            };
            const response = responseMap[responseKey];
            
            // Determine correct response and accuracy
            let correct, accuracy;
            if (state.isPractice) {
                const navType = state.currentTrial < 2 ? 'egocentric' : 'allocentric';
                const stimuli = stimulusMapping.easy;
                const stimulus = stimuli[state.currentTrial % stimuli.length];
                correct = navType === 'egocentric' ? stimulus.egocentric_correct : stimulus.allocentric_correct;
            } else {
                const block = config.blocks[state.currentBlock];
                const stimuli = stimulusMapping[block.difficulty];
                const stimulus = stimuli[state.currentTrial % stimuli.length];
                correct = block.navType === 'egocentric' ? stimulus.egocentric_correct : stimulus.allocentric_correct;
            }
            
            accuracy = response === correct ? 1 : 0;
            
            // Record trial data
            const trialData = {
                participant_id: state.participantInfo.id,
                block: state.currentBlock,
                trial: state.currentTrial + 1,
                navigation_type: state.isPractice ? (state.currentTrial < 2 ? 'egocentric' : 'allocentric') : 
                                config.blocks[state.currentBlock].navType,
                difficulty: state.isPractice ? 'practice' : config.blocks[state.currentBlock].difficulty,
                response: response,
                correct_response: correct,
                accuracy: accuracy,
                rt: rt,
                timestamp: new Date().toISOString()
            };
            
            state.blockData.push(trialData);
            
            // Show feedback
            showFeedback(accuracy);
        }

        // Show feedback
        function showFeedback(accuracy) {
            document.getElementById('stimulus-screen').classList.remove('active');
            
            if (state.isPractice) {
                // Show detailed feedback for practice
                const feedbackScreen = document.getElementById('feedback-screen');
                const feedbackText = document.getElementById('feedback-text');
                
                feedbackText.textContent = accuracy ? 'Correct!' : 'Incorrect';
                feedbackText.style.color = accuracy ? 'green' : 'red';
                
                feedbackScreen.classList.add('active');
                
                setTimeout(() => {
                    feedbackScreen.classList.remove('active');
                    state.currentTrial++;
                    runPracticeTrial();
                }, 1500);
            } else {
                // Brief or no feedback for main experiment
                setTimeout(() => {
                    nextTrial();
                }, config.feedbackDuration);
            }
        }

        // Next trial
        function nextTrial() {
            state.currentTrial++;
            
            if (state.currentTrial >= config.trialsPerBlock) {
                // Block complete
                state.allData = state.allData.concat(state.blockData);
                state.currentBlock++;
                
                if (state.currentBlock >= config.blocks.length) {
                    // Experiment complete
                    showCompletion();
                } else {
                    // Next block
                    showBlockInstructions();
                }
            } else {
                // Next trial in current block
                const block = config.blocks[state.currentBlock];
                const stimuli = stimulusMapping[block.difficulty];
                const stimulus = stimuli[state.currentTrial % stimuli.length];
                
                presentStimulus(stimulus, block.navType, block.difficulty);
            }
        }

        // Update progress display
        function updateProgress() {
            const progress = document.getElementById('progress');
            const totalTrials = config.blocks.length * config.trialsPerBlock;
            const completedTrials = state.currentBlock * config.trialsPerBlock + state.currentTrial;
            
            progress.textContent = `Block ${state.currentBlock + 1}/${config.blocks.length} | Trial ${state.currentTrial}/${config.trialsPerBlock}`;
        }

        // Show completion screen
        function showCompletion() {
            const feedbackScreen = document.getElementById('feedback-screen');
            const feedbackText = document.getElementById('feedback-text');
            const continueButton = document.getElementById('continue-button');
            const downloadButton = document.getElementById('download-data');
            
            // Calculate overall accuracy
            const totalCorrect = state.allData.filter(d => d.accuracy === 1).length;
            const accuracy = (totalCorrect / state.allData.length * 100).toFixed(1);
            
            feedbackText.innerHTML = `
                <h2>Experiment Complete!</h2>
                <p>Thank you for participating.</p>
                <p>Overall accuracy: ${accuracy}%</p>
                <p>Click below to download your data.</p>
            `;
            feedbackText.style.color = '#333';
            
            continueButton.style.display = 'none';
            downloadButton.style.display = 'inline-block';
            feedbackScreen.classList.add('active');
        }

        // Download data as CSV
        function downloadData() {
            // Convert data to CSV
            const headers = Object.keys(state.allData[0]);
            const csvContent = [
                headers.join(','),
                ...state.allData.map(row => 
                    headers.map(header => row[header]).join(',')
                )
            ].join('\n');
            
            // Create download link
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `spatial_nav_${state.participantInfo.id}_${Date.now()}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>