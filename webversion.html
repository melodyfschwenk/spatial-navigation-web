<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Spatial Navigation Task</title>

  <!-- Make sure this file is in the same folder as this HTML.
       If your HTML is in /docs or a subfolder, keep the relative path consistent. -->
  <script src="./stimulus_mappings.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background: white;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    #experiment-container {
      position: relative;
      width: 100%;
      max-width: 800px;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: white;
      overflow: hidden;
    }

    /* Screens */
    #instruction-screen, #stimulus-screen, #feedback-screen, #data-entry-screen {
      display: none;
      text-align: center;
      padding: 20px;
      opacity: 0;
      transition: opacity 0.25s ease-in-out;
    }
    #instruction-screen.active, #stimulus-screen.active,
    #feedback-screen.active, #data-entry-screen.active {
      display: block;
      opacity: 1;
    }

    #stimulus-image {
      max-width: 500px;
      max-height: 500px;
      border: 2px solid #ddd;
    }
    .instruction-text {
      font-size: 18px;
      line-height: 1.5;
      color: #333;
      max-width: 600px;
      margin: 0 auto;
      min-height: 140px;
    }

    .button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 16px;
      cursor: pointer;
      margin: 10px;
      border-radius: 4px;
      transition: transform 0.1s ease, box-shadow 0.1s ease, background 0.1s ease;
    }
    .button:hover {
      background: #45a049;
      transform: translateY(-1px);
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    .button:disabled {
      background: #cccccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .fixation {
      font-size: 48px;
      font-weight: bold;
      color: #333;
    }
    .progress {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 14px;
      color: #666;
      background: #f9f9f9;
      padding: 5px 10px;
      border-radius: 5px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      z-index: 50;
    }

    .nav-type-header {
      padding: 10px 20px;
      margin: 20px 0;
      font-weight: bold;
      color: white;
      font-size: 20px;
      border-radius: 8px;
    }
    .egocentric-header { background: linear-gradient(135deg, #4CAF50, #45a049); }
    .allocentric-header { background: linear-gradient(135deg, #9C27B0, #8E24AA); }
    .control-header    { background: linear-gradient(135deg, #FF9800, #F57C00); }

    input[type="text"], input[type="number"], select {
      padding: 8px;
      margin: 5px;
      font-size: 16px;
      border: 1px solid #ddd;
      border-radius: 4px;
      width: 200px;
    }
    .form-group { margin: 15px 0; }
    .form-group label {
      display: inline-block;
      width: 150px;
      text-align: right;
      margin-right: 10px;
    }
    #download-data { display: none; background: #2196F3; }
    #download-data:hover { background: #1976D2; }
    #participant-id-display {
      font-weight: bold;
      color: #4CAF50;
      font-size: 18px;
      padding: 10px;
      background: #f0f0f0;
      border-radius: 5px;
      margin: 10px 0;
      display: none;
    }
    .group-description { font-size: 12px; color: #666; margin-top: 5px; font-style: italic; }
    .loading { color: #999; font-style: italic; }

    /* Inline error banner for mapping issues */
    #inline-error {
      display: none;
      color: #b00020;
      background: #fde7ea;
      border: 1px solid #f5c7ce;
      padding: 10px 14px;
      border-radius: 6px;
      max-width: 640px;
      margin: 12px auto 0;
      text-align: left;
      font-size: 14px;
    }
    #inline-error code { background: #fff; padding: 2px 4px; border-radius: 4px; }
  </style>
</head>
<body>
  <div id="experiment-container">
    <div class="progress" id="progress"></div>

    <!-- Data Entry Screen -->
    <div id="data-entry-screen" class="active">
      <h2>Spatial Navigation Task</h2>

      <div class="form-group">
        <label>Participant Group:</label>
        <select id="participant-group" onchange="updateParticipantID()">
          <option value="">Select your group...</option>
          <option value="DF">Deaf Fluent Signer</option>
          <option value="HF">Hearing Fluent Signer</option>
          <option value="DNF">Deaf Non-Fluent Signer</option>
          <option value="HNF">Hearing Non-Fluent Signer</option>
          <option value="HNS">Hearing Non-Signer</option>
        </select>
      </div>
      <div class="group-description" id="group-desc"></div>

      <div id="participant-id-display">
        Your ID: <span id="generated-id" class="loading">Generating...</span>
      </div>

      <div class="form-group">
        <label>Age:</label>
        <input type="number" id="age" min="18" max="100">
      </div>
      <div class="form-group">
        <label>Gender:</label>
        <select id="gender">
          <option value="">Select...</option>
          <option value="male">Male</option>
          <option value="female">Female</option>
          <option value="non-binary">Non-binary</option>
          <option value="prefer-not">Prefer not to say</option>
        </select>
      </div>
      <div class="form-group">
        <label>Handedness:</label>
        <select id="handedness">
          <option value="">Select...</option>
          <option value="right">Right</option>
          <option value="left">Left</option>
          <option value="ambidextrous">Ambidextrous</option>
        </select>
      </div>

      <div id="inline-error"></div>

      <button class="button" id="start-button" onclick="startExperiment()" disabled>
        Please select your group first
      </button>
    </div>

    <!-- Instruction Screen -->
    <div id="instruction-screen">
      <div id="nav-type-indicator"></div>
      <div class="instruction-text" id="instruction-text"></div>
      <button class="button" onclick="startBlock()">Continue</button>
    </div>

    <!-- Stimulus Screen -->
    <div id="stimulus-screen">
      <img id="stimulus-image" src="" alt="Stimulus">
      <div class="fixation" id="fixation" style="display:none;">+</div>
    </div>

    <!-- Feedback Screen -->
    <div id="feedback-screen">
      <div id="feedback-text" style="font-size: 24px; margin: 20px;"></div>
      <button class="button" id="continue-button" onclick="nextTrial()">Continue</button>
      <button class="button" id="download-data" onclick="downloadData()">Download Data</button>
    </div>
  </div>

  <script>
    // Google Sheets URL - optional, best-effort background sync only
    const GOOGLE_SHEET_URL = 'https://script.google.com/macros/s/AKfycbzw_gLBsA5hY1dU7xZ1Fp67FptHEC9veo95vyId0bBOfu_QLMNFm02Rg0iRzURzx2Cn/exec';

    // Participant ID management
    let generatedParticipantID = null;

    const groupDescriptions = {
      'DF': 'Deaf individuals who are fluent in sign language',
      'HF': 'Hearing individuals who are fluent in sign language',
      'DNF': 'Deaf individuals who are not fluent in sign language',
      'HNF': 'Hearing individuals who are not fluent in sign language',
      'HNS': 'Hearing individuals who do not know sign language'
    };

    // Instant local ID, background sync to Sheets
    function nextIdLocal(groupCode) {
      const key = `lastId_${groupCode}`;
      let n = 0;
      try {
        n = parseInt(localStorage.getItem(key) || '0', 10) + 1;
        localStorage.setItem(key, String(n));
      } catch (e) {
        if (!nextIdLocal.memory) nextIdLocal.memory = {};
        n = (nextIdLocal.memory[groupCode] || 0) + 1;
        nextIdLocal.memory[groupCode] = n;
      }
      return String(n).padStart(3, '0');
    }
    function syncIdToSheets(groupCode, fullId) {
      try {
        fetch(GOOGLE_SHEET_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'text/plain;charset=UTF-8' },
          mode: 'no-cors',
          body: JSON.stringify({ action: 'reserveId', groupCode, id: fullId })
        }).catch(() => {});
      } catch (_) {}
    }
    async function updateParticipantID() {
      const groupSelect = document.getElementById('participant-group');
      const idDisplay = document.getElementById('participant-id-display');
      const generatedIdSpan = document.getElementById('generated-id');
      const startButton = document.getElementById('start-button');
      const groupDesc = document.getElementById('group-desc');

      if (!groupSelect.value) {
        idDisplay.style.display = 'none';
        startButton.disabled = true;
        startButton.textContent = 'Please select your group first';
        groupDesc.textContent = '';
        generatedParticipantID = null;
        return;
      }

      groupDesc.textContent = groupDescriptions[groupSelect.value];
      idDisplay.style.display = 'block';
      generatedIdSpan.textContent = 'Generating...';
      generatedIdSpan.className = 'loading';
      startButton.disabled = true;
      startButton.textContent = 'Generating ID...';

      // Instant local ID
      const num = nextIdLocal(groupSelect.value);
      generatedParticipantID = `${groupSelect.value}-online-${num}`;

      // Show it and unlock Start immediately
      generatedIdSpan.textContent = generatedParticipantID;
      generatedIdSpan.className = '';
      startButton.disabled = false;
      startButton.textContent = 'Start Experiment';

      // Background sync
      syncIdToSheets(groupSelect.value, generatedParticipantID);
    }

    // Best-effort data save
    async function saveToGoogleSheet(trialData) {
      try {
        trialData.user_agent = navigator.userAgent;
        await fetch(GOOGLE_SHEET_URL, {
          method: 'POST',
          mode: 'no-cors',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(trialData)
        });
      } catch (error) {
        console.error('Failed to save to Google Sheets:', error);
      }
    }

    async function saveExperimentSummary() {
      const summary = {
        participant_id: state.participantInfo.id,
        participant_group: state.participantInfo.group,
        age: state.participantInfo.age,
        gender: state.participantInfo.gender,
        handedness: state.participantInfo.handedness,
        total_trials: state.allData.length,
        total_correct: state.allData.filter(d => d.accuracy === 1).length,
        overall_accuracy: (state.allData.filter(d => d.accuracy === 1).length / state.allData.length * 100).toFixed(1),
        mean_rt: (state.allData.reduce((sum, d) => sum + (d.rt_ms || 0), 0) / state.allData.filter(d => d.rt_ms !== null).length).toFixed(0),
        completion_time: new Date().toISOString(),
        trial: 'SUMMARY',
        block: 'SUMMARY',
        navigation_type: 'SUMMARY',
        difficulty: 'SUMMARY'
      };
      await saveToGoogleSheet(summary);
    }

    // Config and state
    const config = {
      trialsPerBlock: 15,
      maxResponseTime: 3000,
      feedbackDuration: 500,
      fixationDuration: 800,
      practiceTrials: 4,
      blocks: []
    };
    let state = {
      participantInfo: {},
      currentBlock: 0,
      currentTrial: 0,
      blockData: [],
      allData: [],
      trialStartTime: null,
      stimulusOnsetTime: null,
      isPractice: false,
      currentBlockTrials: [],
      blockTrialOrder: {}
    };

    // RNG and shuffle
    class SeededRandom {
      constructor(seed) { this.seed = seed; }
      random() {
        this.seed = (this.seed * 1664525 + 1013904223) % 2147483647;
        return this.seed / 2147483647;
      }
      randInt(min, max) { return Math.floor(this.random() * (max - min)) + min; }
    }
    function shuffleArray(array, rng = null) {
      const out = [...array];
      for (let i = out.length - 1; i > 0; i++) {
        const j = rng ? rng.randInt(0, i + 1) : Math.floor(Math.random() * (i + 1));
        [out[i], out[j]] = [out[j], out[i]];
      }
      return out;
    }
    function createSeedFromParticipantId(participantId) {
      const matches = participantId.match(/\d+/);
      if (matches) return parseInt(matches[0], 10);
      let seed = 0;
      for (let i = 0; i < participantId.length; i++) seed += participantId.charCodeAt(i);
      return seed;
    }

    function prepareBlockTrials(stimuli, trialsPerBlock, blockNum = 0, participantId = null) {
      let trials = [];
      let rng = null;
      if (participantId) {
        const baseSeed = createSeedFromParticipantId(participantId);
        rng = new SeededRandom(baseSeed + blockNum * 1000);
      }
      if (stimuli.length >= trialsPerBlock) {
        const indices = Array.from({ length: stimuli.length }, (_, i) => i);
        trials = shuffleArray(indices, rng).slice(0, trialsPerBlock).map(i => stimuli[i]);
      } else {
        const fullCycles = Math.floor(trialsPerBlock / stimuli.length);
        const remainder = trialsPerBlock % stimuli.length;
        for (let i = 0; i < fullCycles; i++) trials = trials.concat(shuffleArray(stimuli, rng));
        if (remainder > 0) trials = trials.concat(shuffleArray(stimuli, rng).slice(0, remainder));
      }
      for (let pass = 0; pass < 3; pass++) trials = shuffleArray(trials, rng);
      return trials;
    }

    function generateBlockSequence(participantId) {
      const matches = participantId.match(/\d+/);
      const number = matches ? parseInt(matches[0], 10) : 0;
      const cb = (number % 4) + 1;
      const latinSquare = [
        [['egocentric', 'easy'], ['egocentric', 'hard'], ['allocentric', 'easy'], ['allocentric', 'hard']],
        [['egocentric', 'hard'], ['allocentric', 'hard'], ['egocentric', 'easy'], ['allocentric', 'easy']],
        [['allocentric', 'easy'], ['egocentric', 'easy'], ['allocentric', 'hard'], ['egocentric', 'hard']],
        [['allocentric', 'hard'], ['allocentric', 'easy'], ['egocentric', 'hard'], ['egocentric', 'easy']]
      ];
      const sequence = latinSquare[cb - 1];
      const blocks = [];
      sequence.forEach(([navType, difficulty]) => {
        blocks.push({ navType, difficulty });
        blocks.push({ navType, difficulty });
      });
      blocks.splice(4, 0, { navType: 'control', difficulty: 'control' });
      return blocks;
    }

    function transitionScreen(fromEl, toEl) {
      if (fromEl) {
        fromEl.style.opacity = '0';
        setTimeout(() => { fromEl.classList.remove('active'); }, 220);
      }
      if (toEl) {
        toEl.classList.add('active');
        requestAnimationFrame(() => { toEl.style.opacity = '1'; });
      }
    }

    function showInlineError(msg, tipsHtml = '') {
      const box = document.getElementById('inline-error');
      box.innerHTML = `<strong>Setup issue:</strong> ${msg}${tipsHtml ? '<br><br>' + tipsHtml : ''}`;
      box.style.display = 'block';
    }
    function hideInlineError() {
      const box = document.getElementById('inline-error');
      box.style.display = 'none';
      box.textContent = '';
    }

    function startExperiment() {
      // quick click guard
      const startBtn = document.getElementById('start-button');
      startBtn.disabled = true;
      setTimeout(() => { startBtn.disabled = false; }, 400);

      hideInlineError();

      if (!generatedParticipantID) {
        alert('Please select your participant group first');
        return;
      }
      const age = document.getElementById('age').value;
      const gender = document.getElementById('gender').value;
      const handedness = document.getElementById('handedness').value;
      if (!age || !gender || !handedness) {
        alert('Please fill in all required fields (Age, Gender, Handedness)');
        return;
      }

      // Validate stimulus mappings right here, not at load
      const tips = `
        <div>
          <div>Check that <code>stimulus_mappings.js</code> is:</div>
          <ul style="margin:6px 0 0 16px;">
            <li>in the same folder as this HTML file</li>
            <li>spelled exactly the same - case sensitive</li>
            <li>referenced as <code>&lt;script src="./stimulus_mappings.js"&gt;</code></li>
            <li>served by GitHub Pages in the same site path</li>
          </ul>
          <div style="margin-top:6px;">Open DevTools - Console for any 404 or CORS error on the script.</div>
        </div>`;
      if (typeof stimulusMapping === 'undefined') {
        showInlineError('stimulus_mappings.js did not load.', tips);
        return;
      }

      const required = ['easy', 'hard', 'control'];
      const missing = required.filter(c => !stimulusMapping[c] || !Array.isArray(stimulusMapping[c]) || stimulusMapping[c].length === 0);
      if (missing.length) {
        showInlineError(`Missing or empty stimulus arrays: ${missing.join(', ')}`);
        return;
      }

      state.participantInfo = {
        id: generatedParticipantID,
        group: document.getElementById('participant-group').value,
        age, gender, handedness,
        timestamp: new Date().toISOString()
      };

      config.blocks = generateBlockSequence(state.participantInfo.id);

      // Pre-randomize all blocks
      state.blockTrialOrder = {};
      config.blocks.forEach((block, idx) => {
        const stimuli = stimulusMapping[block.difficulty];
        state.blockTrialOrder[idx] = prepareBlockTrials(stimuli, config.trialsPerBlock, idx + 1, state.participantInfo.id);
      });

      state.isPractice = true;
      showPracticeInstructions();

      const dataEntry = document.getElementById('data-entry-screen');
      transitionScreen(dataEntry, document.getElementById('instruction-screen'));
    }

    function showPracticeInstructions() {
      const instructionText = document.getElementById('instruction-text');
      const navIndicator = document.getElementById('nav-type-indicator');
      navIndicator.className = 'nav-type-header';
      navIndicator.textContent = 'Practice';
      instructionText.innerHTML = `
        <h3>Practice Phase</h3>
        <p>You will now practice the two navigation types:</p>
        <p><strong>PLAYER VIEW:</strong> Navigate as if you are the player<br>
        UP = forward, DOWN = backward, LEFT or RIGHT = turn</p>
        <p><strong>MAP VIEW:</strong> Navigate using map directions<br>
        UP = north, DOWN = south, LEFT = west, RIGHT = east</p>
        <p>Press Continue to start practice trials.</p>
      `;
      document.getElementById('instruction-screen').classList.add('active');
      document.getElementById('instruction-screen').style.opacity = '1';
      updateProgress();
    }

    function showBlockInstructions() {
      const block = config.blocks[state.currentBlock];
      const instructionScreen = document.getElementById('instruction-screen');
      const instructionText = document.getElementById('instruction-text');
      const navIndicator = document.getElementById('nav-type-indicator');

      navIndicator.className = `nav-type-header ${block.navType}-header`;
      navIndicator.textContent =
        block.navType === 'egocentric' ? 'PLAYER VIEW' :
        block.navType === 'allocentric' ? 'MAP VIEW' : 'ARROW FOLLOWING';

      const instructions = {
        egocentric: `Navigate from the gray player to the red stop sign.<br><br>
          Use arrow keys as if YOU are the player:<br>
          UP = Move forward<br>
          DOWN = Move backward<br>
          LEFT = Turn left<br>
          RIGHT = Turn right`,
        allocentric: `Navigate from the gray player to the red stop sign.<br><br>
          Use arrow keys for map directions:<br>
          UP = Move north (top of screen)<br>
          DOWN = Move south (bottom)<br>
          LEFT = Move west (left side)<br>
          RIGHT = Move east (right side)`,
        control: `Follow the arrows shown.<br><br>
          Press the arrow key matching the FIRST arrow from the player.`
      };
      instructionText.innerHTML = instructions[block.navType];

      transitionScreen(null, instructionScreen);
      updateProgress();
    }

    function startBlock() {
      const instructionScreen = document.getElementById('instruction-screen');
      transitionScreen(instructionScreen, null);

      if (state.isPractice) {
        state.currentTrial = 0;
        state.blockData = [];
        const n = Math.min(stimulusMapping.easy.length, config.practiceTrials);
        const practiceStimuli = stimulusMapping.easy.slice(0, n);
        state.currentBlockTrials =
          n === config.practiceTrials ? practiceStimuli
                                      : prepareBlockTrials(practiceStimuli, config.practiceTrials, 0, state.participantInfo.id);
        runPracticeTrial();
      } else {
        state.currentTrial = 0;
        state.blockData = [];
        state.currentBlockTrials = state.blockTrialOrder[state.currentBlock];
        nextTrial();
      }
    }

    function runPracticeTrial() {
      if (state.currentTrial >= config.practiceTrials) {
        state.isPractice = false;
        state.currentBlock = 0;
        showBlockInstructions();
        return;
      }
      const navType = state.currentTrial < 2 ? 'egocentric' : 'allocentric';
      if (!state.currentBlockTrials || state.currentTrial >= state.currentBlockTrials.length) {
        state.isPractice = false;
        state.currentBlock = 0;
        showBlockInstructions();
        return;
      }
      const stimulus = state.currentBlockTrials[state.currentTrial];
      presentStimulus(stimulus, navType, 'practice');
    }

    function presentStimulus(stimulus, navType, difficulty) {
      const stimulusScreen = document.getElementById('stimulus-screen');
      const stimulusImage = document.getElementById('stimulus-image');
      const fixation = document.getElementById('fixation');

      fixation.style.display = 'block';
      stimulusImage.style.display = 'none';
      transitionScreen(null, stimulusScreen);

      setTimeout(() => {
        fixation.style.display = 'none';
        stimulusImage.style.display = 'block';
        stimulusImage.src = stimulus.file;

        state.stimulusOnsetTime = Date.now();
        state.trialStartTime = Date.now();
        state.currentStimulus = stimulus;

        document.addEventListener('keydown', handleResponse);
        state.responseTimeout = setTimeout(() => handleResponse({ key: 'timeout' }), config.maxResponseTime);
      }, config.fixationDuration);
    }

    function handleResponse(event) {
      const validKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'timeout'];
      const responseKey = event.key || event;
      if (!validKeys.includes(responseKey)) return;

      clearTimeout(state.responseTimeout);
      document.removeEventListener('keydown', handleResponse);

      const rt = responseKey === 'timeout' ? null : Date.now() - state.stimulusOnsetTime;
      const responseMap = { 'ArrowUp': 'up', 'ArrowDown': 'down', 'ArrowLeft': 'left', 'ArrowRight': 'right', 'timeout': 'none' };
      const response = responseMap[responseKey];

      let correct, stimulus_id;
      if (state.isPractice) {
        const navType = state.currentTrial < 2 ? 'egocentric' : 'allocentric';
        const stimulus = state.currentBlockTrials[state.currentTrial];
        correct = navType === 'egocentric' ? stimulus.egocentric_correct : stimulus.allocentric_correct;
        stimulus_id = stimulus.id;
      } else {
        const block = config.blocks[state.currentBlock];
        const stimulus = state.currentBlockTrials[state.currentTrial];
        correct = block.navType === 'egocentric' ? stimulus.egocentric_correct : stimulus.allocentric_correct;
        stimulus_id = stimulus.id;
      }
      const accuracy = response === correct ? 1 : 0;

      const trialData = {
        participant_id: state.participantInfo.id,
        participant_group: state.participantInfo.group,
        age: state.participantInfo.age,
        gender: state.participantInfo.gender,
        handedness: state.participantInfo.handedness,
        block: state.currentBlock,
        trial: state.currentTrial + 1,
        navigation_type: state.isPractice ? (state.currentTrial < 2 ? 'egocentric' : 'allocentric') : config.blocks[state.currentBlock].navType,
        difficulty: state.isPractice ? 'practice' : config.blocks[state.currentBlock].difficulty,
        stimulus_id,
        response,
        correct_response: correct,
        accuracy,
        rt_ms: rt,
        timestamp: new Date().toISOString()
      };

      state.blockData.push(trialData);
      saveToGoogleSheet(trialData);
      showFeedback(accuracy);
    }

    function showFeedback(accuracy) {
      const stimulusScreen = document.getElementById('stimulus-screen');
      if (state.isPractice) {
        const feedbackScreen = document.getElementById('feedback-screen');
        const feedbackText = document.getElementById('feedback-text');
        feedbackText.textContent = accuracy ? 'Correct!' : 'Incorrect';
        feedbackText.style.color = accuracy ? 'green' : 'red';

        transitionScreen(stimulusScreen, feedbackScreen);
        setTimeout(() => {
          transitionScreen(feedbackScreen, null);
          state.currentTrial++;
          runPracticeTrial();
        }, 1500);
      } else {
        transitionScreen(stimulusScreen, null);
        setTimeout(() => nextTrial(), config.feedbackDuration);
      }
    }

    function nextTrial() {
      state.currentTrial++;
      if (state.currentTrial >= config.trialsPerBlock) {
        state.allData = state.allData.concat(state.blockData);
        state.currentBlock++;
        if (state.currentBlock >= config.blocks.length) {
          showCompletion();
        } else {
          showBlockInstructions();
        }
      } else {
        const block = config.blocks[state.currentBlock];
        if (!state.currentBlockTrials || state.currentTrial >= state.currentBlockTrials.length) {
          state.currentBlock++;
          if (state.currentBlock >= config.blocks.length) showCompletion();
          else showBlockInstructions();
          return;
        }
        const stimulus = state.currentBlockTrials[state.currentTrial];
        presentStimulus(stimulus, block.navType, block.difficulty);
        updateProgress();
      }
    }

    function updateProgress() {
      const progress = document.getElementById('progress');
      const totalBlocks = config.blocks.length || 0;
      const currentBlock = Math.min(state.currentBlock + 1, totalBlocks || 1);
      // Display trials using 1-based indexing so the first trial shows as 1
      const trialNum = Math.min(state.currentTrial + 1, config.trialsPerBlock);
      progress.textContent = `Block ${currentBlock}/${totalBlocks} | Trial ${trialNum}/${config.trialsPerBlock}`;
    }

    async function showCompletion() {
      const feedbackScreen = document.getElementById('feedback-screen');
      const feedbackText = document.getElementById('feedback-text');
      const continueButton = document.getElementById('continue-button');
      const downloadButton = document.getElementById('download-data');

      const totalCorrect = state.allData.filter(d => d.accuracy === 1).length;
      const accuracy = (totalCorrect / state.allData.length * 100).toFixed(1);

      await saveExperimentSummary();

      feedbackText.innerHTML = `
        <h2>Experiment Complete!</h2>
        <p>Thank you for participating.</p>
        <p>Your data has been automatically saved.</p>
        <p>Overall accuracy: ${accuracy}%</p>
        <p>Participant ID: ${state.participantInfo.id}</p>
        <hr style="margin: 20px 0;">
        <p style="font-size: 16px;">You may close this window now.</p>
        <p style="font-size: 14px; color: #666;">Optional: Download a backup copy of your data below</p>
      `;
      feedbackText.style.color = '#333';

      continueButton.style.display = 'none';
      downloadButton.style.display = 'inline-block';

      transitionScreen(null, feedbackScreen);
    }

    function downloadData() {
      if (!state.allData.length) return;
      const headers = Object.keys(state.allData[0]);
      const csvContent = [
        headers.join(','),
        ...state.allData.map(row => headers.map(h => row[h]).join(','))
      ].join('\n');

      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `spatial_nav_${state.participantInfo.id}_${Date.now()}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }

    // Do not disable Start at load - just log what we see
    window.addEventListener('load', function() {
      if (typeof stimulusMapping === 'undefined') {
        console.warn('stimulus_mappings.js not detected at load - Start will validate again.');
      } else {
        console.log('✓ Stimulus mappings loaded:', {
          easy: stimulusMapping.easy?.length || 0,
          hard: stimulusMapping.hard?.length || 0,
          control: stimulusMapping.control?.length || 0
        });
      }
    });
  </script>
</body>
</html>
