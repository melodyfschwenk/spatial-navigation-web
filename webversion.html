<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Spatial Navigation Task</title>
  <style>
    /* Base layout */
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background: white;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    #experiment-container {
      width: 100%;
      max-width: 800px;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: white;
      position: relative;
      overflow: hidden;
    }

    /* Screens */
    .screen {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
      text-align: center;
      opacity: 0;
      visibility: hidden;
      transform: translateY(6px);
      transition: opacity 200ms ease, transform 200ms ease, visibility 0s linear 200ms;
      will-change: opacity, transform;
    }
    .screen.active {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
      transition: opacity 200ms ease, transform 200ms ease, visibility 0s;
    }

    /* Fixed 500x500 stage */
    .stimulus-stage {
      width: 500px;
      height: 500px;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Image */
    #stimulus-image {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      border: 2px solid #ddd;
      box-sizing: border-box;
      opacity: 0;
      transition: opacity 150ms ease;
      will-change: opacity;
      pointer-events: none;
    }
    #stimulus-image.show { opacity: 1; }

    /* Fixation */
    .fixation {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 120ms ease;
      will-change: opacity;
      pointer-events: none;
    }
    .fixation.show { opacity: 1; }

    /* Trial feedback overlay (no screen switch) */
    .trial-feedback {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      background: rgba(255,255,255,0.95);
      border: 1px solid #e0e0e0;
      opacity: 0;
      transition: opacity 120ms ease;
      pointer-events: none;
    }
    .trial-feedback.show { opacity: 1; }
    .trial-feedback.correct { color: #1b5e20; border-color: #c8e6c9; }
    .trial-feedback.incorrect { color: #b71c1c; border-color: #ffcdd2; }

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce) {
      .screen { transition: none; transform: none; }
      #stimulus-image, .fixation, .trial-feedback { transition: none; }
    }

    .instruction-text {
      font-size: 18px;
      line-height: 1.5;
      color: #333;
      max-width: 600px;
      margin: 0 auto;
    }

    .button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 16px;
      cursor: pointer;
      margin: 10px;
      border-radius: 4px;
    }
    .button:hover { background: #45a049; }
    .button:disabled { background: #cccccc; cursor: not-allowed; }

    .progress {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 14px;
      color: #666;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #eee;
    }

    .nav-type-header { padding: 10px 20px; margin: 20px 0; font-weight: bold; color: white; font-size: 20px; border-radius: 5px; }
    .egocentric-header { background: #4CAF50; }
    .allocentric-header { background: #9C27B0; }
    .control-header   { background: #FF9800; }

    input[type="text"], input[type="number"], select {
      padding: 8px;
      margin: 5px;
      font-size: 16px;
      border: 1px solid #ddd;
      border-radius: 4px;
      width: 200px;
    }
    .form-group { margin: 15px 0; }
    .form-group label { display: inline-block; width: 150px; text-align: right; margin-right: 10px; }

    #download-data { display: none; background: #2196F3; }
    #download-data:hover { background: #1976D2; }

    #participant-id-display {
      font-weight: bold;
      color: #4CAF50;
      font-size: 18px;
      padding: 10px;
      background: #f0f0f0;
      border-radius: 5px;
      margin: 10px 0;
    }

    .group-description { font-size: 12px; color: #666; margin-top: 5px; font-style: italic; }
    .loading { color: #999; font-style: italic; }

    .debug-info {
      position: fixed; bottom: 10px; left: 10px;
      font-size: 10px; color: #999; background: rgba(255,255,255,0.9);
      padding: 5px; border: 1px solid #ddd; display: none; max-width: 300px;
    }
    .debug-info.active { display: block; }
  </style>
</head>
<body>
  <div id="experiment-container">
    <div class="progress" id="progress"></div>

    <!-- Data Entry Screen -->
    <div id="data-entry-screen" class="screen active">
      <h2>Spatial Navigation Task</h2>

      <div class="form-group">
        <label>Participant Group:</label>
        <select id="participant-group" onchange="updateParticipantID()">
          <option value="">Select your group...</option>
          <option value="DF">Deaf Fluent Signer</option>
          <option value="HF">Hearing Fluent Signer</option>
          <option value="DNF">Deaf Non-Fluent Signer</option>
          <option value="HNF">Hearing Non-Fluent Signer</option>
          <option value="HNS">Hearing Non-Signer</option>
        </select>
      </div>
      <div class="group-description" id="group-desc"></div>

      <div id="participant-id-display" style="display:none;">
        Your ID: <span id="generated-id" class="loading">Generating...</span>
      </div>

      <div class="form-group">
        <label>Age:</label>
        <input type="number" id="age" min="18" max="100">
      </div>
      <div class="form-group">
        <label>Gender:</label>
        <select id="gender">
          <option value="">Select...</option>
          <option value="male">Male</option>
          <option value="female">Female</option>
          <option value="non-binary">Non-binary</option>
          <option value="prefer-not">Prefer not to say</option>
        </select>
      </div>
      <div class="form-group">
        <label>Handedness:</label>
        <select id="handedness">
          <option value="">Select...</option>
          <option value="right">Right</option>
          <option value="left">Left</option>
          <option value="ambidextrous">Ambidextrous</option>
        </select>
      </div>

      <button class="button" id="start-button" onclick="startExperiment()" disabled>
        Please select your group first
      </button>
    </div>

    <!-- Instruction Screen (also used after practice) -->
    <div id="instruction-screen" class="screen">
      <div id="nav-type-indicator"></div>
      <div class="instruction-text" id="instruction-text"></div>
      <button class="button" id="instruction-continue" onclick="startBlock()">Continue</button>
    </div>

    <!-- Stimulus Screen -->
    <div id="stimulus-screen" class="screen">
      <div class="stimulus-stage">
        <img id="stimulus-image" src="" alt="Stimulus" />
        <div class="fixation" id="fixation" aria-hidden="true">
          <!-- Crisp SVG fixation cross -->
          <svg class="fixation-svg" width="64" height="64" viewBox="0 0 64 64">
            <line x1="32" y1="10" x2="32" y2="54" stroke="#333" stroke-width="4" stroke-linecap="round"/>
            <line x1="10" y1="32" x2="54" y2="32" stroke="#333" stroke-width="4" stroke-linecap="round"/>
          </svg>
        </div>
        <div id="trial-feedback" class="trial-feedback" aria-live="polite"></div>
      </div>
    </div>

    <!-- Pause Screen (Esc) -->
    <div id="pause-screen" class="screen">
      <h2>Paused</h2>
      <p class="instruction-text">You can take a short break. Press Resume to continue or Quit to end now.</p>
      <div>
        <button class="button" onclick="resumeFromPause()">Resume</button>
        <button class="button" style="background:#d32f2f" onclick="quitStudy()">Quit</button>
      </div>
    </div>

    <!-- Completion / Download Screen -->
    <div id="feedback-screen" class="screen">
      <div id="feedback-text" style="font-size: 24px; margin: 20px;"></div>
      <button class="button" id="continue-button" style="display:none" onclick="nextTrial()">Continue</button>
      <button class="button" id="download-data" onclick="downloadData()">Download Data</button>
    </div>

    <div class="debug-info" id="debug-info"></div>
  </div>

  <!-- Load mappings first -->
  <script src="stimulus_mappings.js"></script>

  <script>
    // Google Sheets URL
    const GOOGLE_SHEET_URL = 'https://script.google.com/macros/s/AKfycbzw_gLBsA5hY1dU7xZ1Fp67FptHEC9veo95vyId0bBOfu_QLMNFm02Rg0iRzURzx2Cn/exec';

    // Debug flag
    const urlParams = new URLSearchParams(window.location.search);
    const debugMode = urlParams.get('debug') === 'true';
    if (debugMode) document.getElementById('debug-info').classList.add('active');

    if (typeof stimulusMapping === 'undefined') {
      alert('Error: Stimulus mappings not loaded. Please refresh the page.');
      console.error('stimulusMapping is not defined');
    } else {
      console.log('Stimulus mappings loaded:', {
        easy: stimulusMapping.easy.length,
        hard: stimulusMapping.hard.length,
        control: stimulusMapping.control.length
      });
    }

    // Group descriptions
    const groupDescriptions = {
      'DF': 'Deaf individuals who are fluent in sign language',
      'HF': 'Hearing individuals who are fluent in sign language',
      'DNF': 'Deaf individuals who are not fluent in sign language',
      'HNF': 'Hearing individuals who are not fluent in sign language',
      'HNS': 'Hearing individuals who do not know sign language'
    };

    // Experiment configuration
    const config = {
      trialsPerBlock: 15,
      maxResponseTime: 3000,
      feedbackDuration: 300,    // faster in-trial feedback
      fixationDuration: 800,
      practiceTrials: 4,
      blocks: [],
      debugMode: debugMode
    };

    // Experiment state
    let state = {
      participantInfo: {},
      currentBlock: 0,
      currentTrial: 0,
      blockData: [],
      allData: [],
      trialStartTime: null,
      stimulusOnsetTime: null,
      isPractice: false,
      currentBlockStimuli: [],
      usedStimuliTracker: {},
      currentStimulus: null,
      currentNavType: null,
      currentDifficulty: null,
      responseTimeout: null,
      paused: false
    };

    const SCREENS = ['data-entry-screen', 'instruction-screen', 'stimulus-screen', 'pause-screen', 'feedback-screen'];
    function switchScreen(id) {
      SCREENS.forEach(sid => {
        const el = document.getElementById(sid);
        if (!el) return;
        if (sid === id) el.classList.add('active'); else el.classList.remove('active');
      });
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function nextFrame() { return new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r))); }

    // Image cache
    const imageCache = new Map();

    async function getUniqueIdFromServer(groupCode) {
      const res = await fetch(GOOGLE_SHEET_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'text/plain;charset=utf-8' },
        body: JSON.stringify({ action: 'nextIdLocked', groupCode })
      });
      if (!res.ok) throw new Error('ID server responded ' + res.status);
      const data = await res.json();
      if (!data.ok || !data.id) throw new Error(data.error || 'Bad response');
      return data.id;
    }

    function fallbackLocalId(groupCode) {
      const bytes = new Uint8Array(8);
      crypto.getRandomValues(bytes);
      const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('').slice(0, 8);
      return `${groupCode}-tmp-${Date.now().toString(36)}-${hex}`;
    }

    async function preloadBlockImages(stimuli) {
      const promises = stimuli.map(stim => {
        const src = stim.file;
        if (imageCache.has(src)) return Promise.resolve();
        const img = new Image();
        img.src = src;
        imageCache.set(src, img);
        if (typeof img.decode === 'function') return img.decode().catch(() => {});
        return new Promise(res => { img.onload = res; img.onerror = res; });
      });
      await Promise.all(promises);
      if (debugMode) updateDebugInfo(`Preloaded ${stimuli.length} images`);
    }

    class RandomGenerator {
      constructor(seed) { this.seed = seed; }
      random() {
        let t = this.seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
      shuffle(array) {
        const arr = [...array];
        for (let i = arr.length - 1; i > 0; i++) {
          const j = Math.floor(this.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }
    }
    function createRandomGenerator(participantId) {
      const seed = participantId.split('').reduce((acc, c) => acc + c.charCodeAt(0), 0) * 1000 + Date.now() % 1000;
      return new RandomGenerator(seed);
    }

    async function updateParticipantID() {
      const groupSelect = document.getElementById('participant-group');
      const startButton = document.getElementById('start-button');
      const groupDesc = document.getElementById('group-desc');

      if (groupSelect.value) {
        groupDesc.textContent = groupDescriptions[groupSelect.value];
        startButton.disabled = false;
        startButton.textContent = 'Start Experiment';
        const idDisplay = document.getElementById('participant-id-display');
        if (idDisplay) idDisplay.style.display = 'none';
      } else {
        groupDesc.textContent = '';
        startButton.disabled = true;
        startButton.textContent = 'Please select your group first';
      }
    }

    function generateBlockSequence(participantId) {
      const matches = participantId.match(/\d+/);
      const number = matches ? parseInt(matches[0], 10) : 0;
      const cb = (number % 4) + 1;

      const latinSquare = [
        [['egocentric', 'easy'], ['egocentric', 'hard'], ['allocentric', 'easy'], ['allocentric', 'hard']],
        [['egocentric', 'hard'], ['allocentric', 'hard'], ['egocentric', 'easy'], ['allocentric', 'easy']],
        [['allocentric', 'easy'], ['egocentric', 'easy'], ['allocentric', 'hard'], ['egocentric', 'hard']],
        [['allocentric', 'hard'], ['allocentric', 'easy'], ['egocentric', 'hard'], ['egocentric', 'easy']]
      ];

      const sequence = latinSquare[cb - 1];
      const blocks = [];
      sequence.forEach(([navType, difficulty]) => {
        blocks.push({ navType, difficulty });
        blocks.push({ navType, difficulty });
      });
      blocks.splice(4, 0, { navType: 'control', difficulty: 'control' });
      return blocks;
    }

    function prepareBlockStimuli(navType, difficulty, blockIndex) {
      if (typeof stimulusMapping === 'undefined') {
        alert('Error: Stimulus files not loaded. Please refresh the page.');
        return [];
      }
      const rng = createRandomGenerator(state.participantInfo.id + '_block' + blockIndex);
      let availableStimuli = [...(stimulusMapping[difficulty] || [])];
      if (availableStimuli.length === 0) return [];

      const conditionKey = `${navType}_${difficulty}`;
      if (!state.usedStimuliTracker[conditionKey]) state.usedStimuliTracker[conditionKey] = [];
      const usedInCondition = state.usedStimuliTracker[conditionKey];

      const unused = availableStimuli.filter(s => !usedInCondition.some(u => u.id === s.id));
      const used = availableStimuli.filter(s => usedInCondition.some(u => u.id === s.id));
      let pool = unused.length >= config.trialsPerBlock ? unused : [...unused, ...used];
      for (let i = 0; i < 5; i++) pool = rng.shuffle(pool);

      const selected = pool.slice(0, config.trialsPerBlock);
      const finalStimuli = rng.shuffle(selected);
      finalStimuli.forEach(stim => { if (!usedInCondition.some(u => u.id === stim.id)) usedInCondition.push(stim); });
      return finalStimuli;
    }

    function updateDebugInfo(message) {
      const debugDiv = document.getElementById('debug-info');
      debugDiv.innerHTML = `<strong>Debug:</strong> ${message}<br>` + debugDiv.innerHTML;
      const lines = debugDiv.innerHTML.split('<br>');
      if (lines.length > 5) debugDiv.innerHTML = lines.slice(0, 5).join('<br>');
    }

    async function saveToGoogleSheet(payload) {
      try {
        const body = { action: 'saveTrial', ...payload, user_agent: navigator.userAgent };
        await fetch(GOOGLE_SHEET_URL, {
          method: 'POST',
          mode: 'no-cors',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
      } catch (e) {
        if (debugMode) console.warn('Save to Sheets failed, using local only');
      }
    }

    async function saveExperimentSummary() {
      const summary = {
        participant_id: state.participantInfo.id,
        participant_group: state.participantInfo.group,
        age: state.participantInfo.age,
        gender: state.participantInfo.gender,
        handedness: state.participantInfo.handedness,
        total_trials: state.allData.length,
        total_correct: state.allData.filter(d => d.accuracy === 1).length,
        overall_accuracy: (state.allData.filter(d => d.accuracy === 1).length / state.allData.length * 100).toFixed(1),
        mean_rt: (state.allData.reduce((sum, d) => sum + (d.rt_ms || 0), 0) / state.allData.filter(d => d.rt_ms !== null).length).toFixed(0),
        completion_time: new Date().toISOString(),
        trial: 'SUMMARY', block: 'SUMMARY', navigation_type: 'SUMMARY', difficulty: 'SUMMARY'
      };
      await saveToGoogleSheet(summary);
    }

    // Start experiment
    async function startExperiment() {
      const group = document.getElementById('participant-group').value;
      const age = document.getElementById('age').value;
      const gender = document.getElementById('gender').value;
      const handedness = document.getElementById('handedness').value;

      if (!group) { alert('Please select your participant group first'); return; }
      if (!age || !gender || !handedness) { alert('Please fill in all required fields (Age, Gender, Handedness)'); return; }

      const startButton = document.getElementById('start-button');
      startButton.disabled = true;
      startButton.textContent = 'Assigning ID...';

      let assignedId;
      try { assignedId = await getUniqueIdFromServer(group); }
      catch (err) { console.warn('ID server failed, using temp ID:', err); assignedId = fallbackLocalId(group); }

      state.participantInfo = { id: assignedId, group, age, gender, handedness, timestamp: new Date().toISOString() };
      config.blocks = generateBlockSequence(state.participantInfo.id);
      state.usedStimuliTracker = {};
      state.isPractice = true;

      showPracticeInstructions();
      document.getElementById('data-entry-screen').classList.remove('active');

      startButton.disabled = false;
      startButton.textContent = 'Start Experiment';
    }

    // Practice instructions
    function showPracticeInstructions() {
      const instructionText = document.getElementById('instruction-text');
      document.getElementById('nav-type-indicator').className = '';
      document.getElementById('nav-type-indicator').textContent = '';
      instructionText.innerHTML = `
        <h3>Practice Phase</h3>
        <p>You will practice two navigation types:</p>
        <p><strong>PLAYER VIEW:</strong> Navigate as if you are the player<br>
        UP = forward, DOWN = backward, LEFT or RIGHT = turn</p>
        <p><strong>MAP VIEW:</strong> Navigate using map directions<br>
        UP = north, DOWN = south, LEFT = west, RIGHT = east</p>
        <p>Practice auto-advances. Press <strong>Esc</strong> anytime to pause.</p>
      `;
      switchScreen('instruction-screen');
    }

    // After practice, show a single Continue to main task
    function showPracticeComplete() {
      // reset practice flag and counters so the first block can start cleanly
      state.isPractice = false; // so Continue starts main task
      state.currentTrial = 0;
      state.currentBlock = 0;
      state.blockData = [];
      state.currentBlockStimuli = [];

      const instructionText = document.getElementById('instruction-text');
      const navIndicator = document.getElementById('nav-type-indicator');
      navIndicator.className = '';
      navIndicator.textContent = '';

      // ensure the continue button is active after practice
      const contBtn = document.getElementById('instruction-continue');
      if (contBtn) contBtn.disabled = false;

      instructionText.innerHTML = `
        <h3>Practice Complete</h3>
        <p>Great job! The main task will begin next.</p>
        <p>You can take a short break now. Press <strong>Continue</strong> when you're ready.</p>
        <p>Remember: You can press <strong>Esc</strong> between trials or at block breaks to pause.</p>
      `;
      switchScreen('instruction-screen');
    }

    // Block instructions (continue between blocks)
    function showBlockInstructions() {
      const block = config.blocks[state.currentBlock];
      const instructionText = document.getElementById('instruction-text');
      const navIndicator = document.getElementById('nav-type-indicator');

      navIndicator.className = `nav-type-header ${block.navType}-header`;
      navIndicator.textContent =
        block.navType === 'egocentric' ? 'PLAYER VIEW' :
        block.navType === 'allocentric' ? 'MAP VIEW' : 'ARROW FOLLOWING';

      const instructions = {
        egocentric: `Navigate from the gray player to the red stop sign.<br><br>
                     Use arrow keys as if YOU are the player:<br>
                     UP = forward, DOWN = backward, LEFT = turn left, RIGHT = turn right`,
        allocentric: `Navigate from the gray player to the red stop sign.<br><br>
                      Use arrow keys for map directions:<br>
                      UP = north, DOWN = south, LEFT = west, RIGHT = east`,
        control: `Follow the arrows shown.<br><br>
                  Press the arrow key matching the FIRST arrow from the player.`
      };
      instructionText.innerHTML = `
        ${instructions[block.navType]}
        <p style="margin-top:12px;color:#666;font-size:14px;">Trials auto-advance. Press <strong>Esc</strong> to pause at any time.</p>
      `;
      updateProgress();
      switchScreen('instruction-screen');
    }

    // Start current block
    async function startBlock() {
      if (state.isPractice) {
        state.currentTrial = 0;
        state.blockData = [];
        await sleep(150);
        runPracticeTrial();
        return;
      }
      const block = config.blocks[state.currentBlock];
      state.currentBlockStimuli = prepareBlockStimuli(block.navType, block.difficulty, state.currentBlock);
      state.currentTrial = 0;
      state.blockData = [];
      await preloadBlockImages(state.currentBlockStimuli);
      await sleep(150);
      nextTrial();
    }

    // Practice trial runner (no continue buttons, auto-advance)
    function runPracticeTrial() {
      if (state.currentTrial >= config.practiceTrials) {
        showPracticeComplete();
        return;
      }
      const navType = state.currentTrial < 2 ? 'egocentric' : 'allocentric';
      const stimuli = stimulusMapping.easy;
      const stimulus = stimuli[state.currentTrial % stimuli.length];
      presentStimulus(stimulus, navType, 'practice');
      // increment happens in showFeedback()
    }

    // Present stimulus with crossfade from fixation
    async function presentStimulus(stimulus, navType, difficulty) {
      const stimulusImage = document.getElementById('stimulus-image');
      const fixation = document.getElementById('fixation');
      const trialFeedback = document.getElementById('trial-feedback');

      // Clear in-place feedback
      trialFeedback.className = 'trial-feedback';
      trialFeedback.textContent = '';

      // Image source (preloaded if available)
      const cached = imageCache.get(stimulus.file);
      stimulusImage.src = cached ? cached.src : stimulus.file;

      // Reset fades
      fixation.classList.remove('show');
      stimulusImage.classList.remove('show');

      switchScreen('stimulus-screen');
      updateProgress();

      await nextFrame();
      fixation.classList.add('show');             // fixation in
      await sleep(config.fixationDuration);
      fixation.classList.remove('show');          // crossfade
      await nextFrame();
      stimulusImage.classList.add('show');        // stimulus in

      // Arm state and response window
      state.stimulusOnsetTime = performance.now();
      state.trialStartTime = performance.now();
      state.currentStimulus = stimulus;
      state.currentNavType = navType;
      state.currentDifficulty = difficulty;

      // Response handler
      document.addEventListener('keydown', handleResponse, { once: true });
      state.responseTimeout = setTimeout(() => handleResponse({ key: 'timeout' }), config.maxResponseTime);
    }

    // Pause handling (Esc)
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        e.preventDefault();
        showPause();
      }
    });

    function showPause() {
      if (state.paused) return;
      state.paused = true;
      clearTimeout(state.responseTimeout);
      // Remove pending one-time response listener by adding a dummy one (safe guard)
      document.addEventListener('keydown', () => {}, { once: true });
      switchScreen('pause-screen');
    }

    function resumeFromPause() {
      state.paused = false;
      // Re-present the current trial cleanly
      if (state.currentStimulus) {
        presentStimulus(state.currentStimulus, state.currentNavType, state.currentDifficulty);
      } else {
        // If paused at an instruction/break screen, just go back there
        switchScreen('instruction-screen');
      }
    }

    function quitStudy() {
      // Optional: append a summary row then show completion
      showCompletion(true);
    }

    // Handle keyboard response
    function handleResponse(event) {
      const validKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'timeout'];
      let responseKey = event.key || event;
      if (!validKeys.includes(responseKey)) {
        // keep listening until timeout
        document.addEventListener('keydown', handleResponse, { once: true });
        return;
      }

      clearTimeout(state.responseTimeout);

      const rt = responseKey === 'timeout' ? null : Math.round(performance.now() - state.stimulusOnsetTime);
      const responseMap = { 'ArrowUp': 'up', 'ArrowDown': 'down', 'ArrowLeft': 'left', 'ArrowRight': 'right', 'timeout': 'none' };
      const response = responseMap[responseKey];

      const correct = state.currentNavType === 'egocentric'
        ? state.currentStimulus.egocentric_correct
        : state.currentStimulus.allocentric_correct;

      const accuracy = response === correct ? 1 : 0;

      const trialData = {
        participant_id: state.participantInfo.id,
        participant_group: state.participantInfo.group,
        age: state.participantInfo.age,
        gender: state.participantInfo.gender,
        handedness: state.participantInfo.handedness,
        block: state.isPractice ? 'practice' : state.currentBlock + 1,
        trial: state.currentTrial,
        navigation_type: state.currentNavType,
        difficulty: state.currentDifficulty,
        stimulus_id: state.currentStimulus.id,
        response, correct_response: correct,
        accuracy, rt_ms: rt,
        timestamp: new Date().toISOString()
      };

      if (!state.isPractice) state.blockData.push(trialData);
      saveToGoogleSheet(trialData);

      showFeedback(accuracy);
    }

    // In-place feedback, then auto-advance
    async function showFeedback(accuracy) {
      const stimulusImage = document.getElementById('stimulus-image');
      const trialFeedback = document.getElementById('trial-feedback');

      // Quick end-of-trial fade and feedback tag
      stimulusImage.classList.remove('show');
      trialFeedback.textContent = accuracy ? 'Correct' : 'Incorrect';
      trialFeedback.classList.add('show', accuracy ? 'correct' : 'incorrect');

      // Advance timing
      await sleep(state.isPractice ? 900 : config.feedbackDuration);

      if (state.isPractice) {
        state.currentTrial++;
        runPracticeTrial();
      } else {
        nextTrial();
      }
    }

    // Next trial (no continue buttons between trials)
    function nextTrial() {
      const total = config.trialsPerBlock;

      if (state.currentTrial >= total) {
        state.allData = state.allData.concat(state.blockData);
        state.currentBlock++;

        if (state.currentBlock >= config.blocks.length) {
          showCompletion();
        } else {
          showBlockInstructions(); // natural break with Continue
        }
        return;
      }

      const block = config.blocks[state.currentBlock];
      const stimulus = state.currentBlockStimuli[state.currentTrial];

      if (!stimulus) {
        console.error('No stimulus for trial', state.currentTrial);
        state.currentTrial++;
        return nextTrial();
      }

      presentStimulus(stimulus, block.navType, block.difficulty);
      state.currentTrial++; // increment after presenting
    }

    function updateProgress() {
      const progress = document.getElementById('progress');
      const totalBlocks = config.blocks.length || 1;
      const b = state.isPractice ? 'Practice' : `${state.currentBlock + 1}/${totalBlocks}`;
      const t = state.isPractice ? `${state.currentTrial + 1}/${config.practiceTrials}` : `${state.currentTrial + 1}/${config.trialsPerBlock}`;
      progress.textContent = `Block ${b} | Trial ${t}`;
    }

    async function showCompletion(aborted=false) {
      const feedbackText = document.getElementById('feedback-text');
      const downloadButton = document.getElementById('download-data');

      const totalCorrect = state.allData.filter(d => d.accuracy === 1).length;
      const accuracy = state.allData.length ? (totalCorrect / state.allData.length * 100).toFixed(1) : '—';

      if (!aborted) await saveExperimentSummary();

      feedbackText.innerHTML = aborted ? `
        <h2>Session Ended</h2>
        <p>You ended the session early.</p>
        <p>Data recorded so far can be downloaded below.</p>
        <p>Participant ID: ${state.participantInfo.id}</p>
      ` : `
        <h2>Experiment Complete!</h2>
        <p>Thank you for participating.</p>
        <p>Overall accuracy: ${accuracy}%</p>
        <p>Participant ID: ${state.participantInfo.id}</p>
        <hr style="margin: 20px 0;">
        <p style="font-size: 16px;">You may close this window now.</p>
        <p style="font-size: 14px; color: #666;">Optional: Download a backup copy of your data below</p>
      `;
      feedbackText.style.color = '#333';

      downloadButton.style.display = 'inline-block';
      switchScreen('feedback-screen');
    }

    function downloadData() {
      if (state.allData.length === 0) {
        alert('No data to download');
        return;
      }
      const headers = Object.keys(state.allData[0]);
      const csvContent = [
        headers.join(','),
        ...state.allData.map(row =>
          headers.map(h => {
            const v = row[h];
            if (typeof v === 'string' && v.includes(',')) return `"${v}"`;
            return v ?? '';
          }).join(',')
        )
      ].join('\n');

      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `spatial_nav_${state.participantInfo.id}_${Date.now()}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
